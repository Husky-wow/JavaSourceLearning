偏向锁的批量再偏向（Bulk Rebias）机制
偏向锁这个机制很特殊， 别的锁在执行完同步代码块后， 都会有释放锁的操作， 而偏向锁并没有直观意义上的“释放锁”操作。
那么作为开发人员， 很自然会产生的一个问题就是， 如果一个对象先偏向于某个线程， 执行完同步代码后， 另一个线程就不
能直接重新获得偏向锁吗？ 答案是可以， JVM 提供了批量再偏向机制（Bulk Rebias）机制

该机制的主要工作原理如下：

引入一个概念 epoch, 其本质是一个时间戳，代表了偏向锁的有效性。从前文描述的对象头结构中可以看到， epoch 存储在可偏向对象的 MarkWord 中。
除了对象中的 epoch, 对象所属的类 class 信息中， 也会保存一个 epoch 值，每当遇到一个全局安全点时， 如果要对 class C 进行批量再偏向，
则首先对 class C 中保存的 epoch 进行增加操作， 得到一个新的 epoch_new然后扫描所有持有 class C 实例的线程栈， 根据线程栈的信息判断出
该线程是否锁定了该对象， 仅将 epoch_new 的值赋给被锁定的对象中，此时class C中保存的epoch_new与对象头中保存的epoch是相等的！如果对象并
没有被任何线程锁定，则此时class C中保存的epoch_new与对象头中保存的epoch是不相等的！

退出安全点后， 当有线程需要尝试获取偏向锁时， 先检查对象头中的Thread ID是否与当前的线程ID相同，如果相同则直接进入。
如果不同，则检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等，如果不相等， 则说明该对象的偏向锁
已经无效了，可以尝试对此对象重新进行偏向操作。
