package com.xxd.jdksource.concurrent.p_hash.h;

/**
 * @author gao
 * @time 2020/05/23 16:27:49
 */

/*
    在确定kv键值对数量的情况下，创建HashMap时，初始容量应该这样计算：
    initialCapacity = (需要存储的元素个数 / 负载因子) + 1
    其中负载因子就是loadfactor，默认为0.75

    比如，我们需要存放到HashMap中的kv键值对的个数为7，而如果我们直接
    将HashMap的初始容量设置为7，经过HashMap处理后，实际容量为8，则
    当该HashMap的元素个数达到8*0.75=6的时候，就会引起一次扩容，这明
    显使我们不想看到的，毕竟扩容是消耗性能的。我们应该减少扩容的几率。

    而如果我们设置初始容量为7/0.75+1=10，则经过HashMap处理后是16.
    这样的话，就算把7个键值对都加入HashMap中，也不会引起一次扩容的！

    问题是，7/0.75=9.3333333333....，经过HashMap处理后仍然是16
    看来不用在7/0.75后面+1啊！？ 这里为什么要加1呢？

    假设我们已知的kv键值对数量不是7而是12的话，如果使用12/0.75=16
    来确定HashMap的初始容量的话，则当12个元素加入HashMap中后，由于
    元素数量达到了16*0.75=12，就会引起一次扩容！这不是我们想要的。

    那么我们再使用12/0.75+1=17来确定HashMap初始化容量，经过HashMap
    处理，最终实际容量为32，这样的话，就算把12个键值对元素全部加入
    HashMap中，也不会引起任何一次的扩容!

    所以，在确定HashMap容量的公式中，+1的意义在于，在确定键值对数量的
    情况下，减少HashMap扩容的几率！

 */
public class App {
}
